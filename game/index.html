<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local WiFi Racing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        .container {
            text-align: center;
        }
        .setup {
            background: #000;
            border: 2px solid #fff;
            padding: 20px;
        }
        h1 {
            font-size: 2em;
            margin: 20px;
            letter-spacing: 4px;
        }
        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px;
        }
        button {
            padding: 12px 30px;
            font-size: 16px;
            border: 2px solid #fff;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            letter-spacing: 2px;
        }
        button:active {
            background: #fff;
            color: #000;
        }
        .status {
            margin: 20px;
            font-size: 14px;
            letter-spacing: 2px;
        }
        #gameCanvas {
            display: block;
            border: 2px solid #fff;
        }
        #gameContainer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        .controller {
            display: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        .control-area {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .stats {
            background: #000;
            border-bottom: 2px solid #fff;
            padding: 10px;
            font-size: 18px;
            letter-spacing: 2px;
        }
        .tilt-info {
            background: #000;
            border-bottom: 2px solid #fff;
            padding: 15px;
            font-size: 14px;
        }
        .controls {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            background: #fff;
        }
        .control-btn {
            background: #000;
            border: none;
            color: #fff;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 4px;
        }
        .control-btn:active {
            background: #fff;
            color: #000;
        }
        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #fff;
            padding: 10px 20px;
            font-size: 20px;
            letter-spacing: 3px;
            z-index: 100;
        }
        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            z-index: 100;
            cursor: pointer;
        }
        .fullscreen-btn:active {
            background: #fff;
            color: #000;
        }
        img {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="setup" id="setup">
            <h1>RACING</h1>
            <div class="buttons">
                <button onclick="startAsPC()">PC</button>
                <button onclick="startAsPhone()">PHONE</button>
            </div>
            <div class="status" id="status">SELECT DEVICE</div>
        </div>
        
        <div id="gameContainer">
            <div class="score-display" id="scoreDisplay">SPEED: 0</div>
        </div>
        
        <div class="controller" id="controller">
            <button class="fullscreen-btn" onclick="goFullscreen()">FULLSCREEN</button>
            <div class="control-area">
                <div class="stats">
                    <div id="phoneSpeed">SPEED: 0</div>
                    <div id="phoneScore">SCORE: 0</div>
                </div>
                <div class="tilt-info" id="tiltInfo">TILT PHONE TO STEER</div>
                <div class="controls">
                    <button class="control-btn" ontouchstart="sendControl('gas', true)" ontouchend="sendControl('gas', false)" onmousedown="sendControl('gas', true)" onmouseup="sendControl('gas', false)">GAS</button>
                    <button class="control-btn" ontouchstart="sendControl('brake', true)" ontouchend="sendControl('brake', false)" onmousedown="sendControl('brake', true)" onmouseup="sendControl('brake', false)">BRAKE</button>
                    <button class="control-btn" ontouchstart="sendControl('left', true)" ontouchend="sendControl('left', false)" onmousedown="sendControl('left', true)" onmouseup="sendControl('left', false)">LEFT</button>
                    <button class="control-btn" ontouchstart="sendControl('right', true)" ontouchend="sendControl('right', false)" onmousedown="sendControl('right', true)" onmouseup="sendControl('right', false)">RIGHT</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const FIXED_ID = 'RACE2024';
        let peer, connection, isPC = false;
        let scene, camera, renderer;
        let car, road = [], obstacles = [];
        let tiltX = 0, tiltY = 0;
        
        const game = {
            carX: 0,
            speed: 0,
            score: 0,
            maxSpeed: 200,
            acceleration: 2,
            braking: 4,
            friction: 0.5,
            steering: 0,
            gas: false,
            brake: false,
            left: false,
            right: false
        };

        function goFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }

        function startAsPC() {
            isPC = true;
            document.getElementById('status').textContent = 'STARTING...';
            peer = new Peer(FIXED_ID);
            
            peer.on('open', () => {
                document.getElementById('setup').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'block';
                initGame();
            });
            
            peer.on('connection', (conn) => {
                connection = conn;
                connection.on('data', handleControl);
                connection.on('open', () => {
                    console.log('Controller connected');
                    startGameLoop();
                });
            });

            peer.on('error', (err) => {
                document.getElementById('status').textContent = 'ERROR: CLOSE OTHER TABS';
            });
        }

        function startAsPhone() {
            isPC = false;
            document.getElementById('status').textContent = 'CONNECTING...';
            
            if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleTilt);
                        }
                    });
            } else if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleTilt);
            }
            
            peer = new Peer();
            peer.on('open', attemptConnection);
        }

        function attemptConnection() {
            connection = peer.connect(FIXED_ID);
            
            connection.on('open', () => {
                document.getElementById('setup').style.display = 'none';
                document.getElementById('controller').style.display = 'block';
                startTiltSending();
            });
            
            connection.on('data', (data) => {
                if (data.speed !== undefined) {
                    document.getElementById('phoneSpeed').textContent = 'SPEED: ' + Math.floor(data.speed);
                    document.getElementById('phoneScore').textContent = 'SCORE: ' + data.score;
                }
            });

            connection.on('error', () => {
                setTimeout(attemptConnection, 1000);
            });
        }

        function handleTilt(event) {
            tiltX = event.gamma || 0;
            tiltY = event.beta || 0;
            document.getElementById('tiltInfo').textContent = 
                `TILT: X:${Math.floor(tiltX)} Y:${Math.floor(tiltY)}`;
        }

        function startTiltSending() {
            setInterval(() => {
                if (connection && connection.open) {
                    connection.send({ tilt: { x: tiltX, y: tiltY } });
                }
            }, 50);
        }

        function sendControl(type, state) {
            if (connection && connection.open) {
                connection.send({ control: type, state: state });
            }
        }

        function handleControl(data) {
            if (data.control) {
                game[data.control] = data.state;
            }
            if (data.tilt) {
                game.steering = Math.max(-1, Math.min(1, data.tilt.x / 30));
            }
        }

        function initGame() {
            const container = document.getElementById('gameContainer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001a33);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 20);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 10, 10);
            scene.add(directionalLight);
            
            // Car - more visible design
            const carGeom = new THREE.BoxGeometry(2, 1, 4);
            const carMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: false });
            car = new THREE.Mesh(carGeom, carMat);
            car.position.y = 0.5;
            scene.add(car);
            
            // Road markers
            for (let i = 0; i < 100; i++) {
                const lineGeom = new THREE.BoxGeometry(0.5, 0.1, 2);
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const line = new THREE.Mesh(lineGeom, lineMat);
                line.position.set(0, 0, -i * 10);
                road.push(line);
                scene.add(line);
            }
            
            // Road edges
            const leftEdgeGeom = new THREE.BoxGeometry(0.3, 0.2, 1000);
            const rightEdgeGeom = new THREE.BoxGeometry(0.3, 0.2, 1000);
            const edgeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const leftEdge = new THREE.Mesh(leftEdgeGeom, edgeMat);
            const rightEdge = new THREE.Mesh(rightEdgeGeom, edgeMat);
            leftEdge.position.set(-15, 0.1, -500);
            rightEdge.position.set(15, 0.1, -500);
            scene.add(leftEdge);
            scene.add(rightEdge);
            
            // Ground plane
            const groundGeom = new THREE.PlaneGeometry(40, 1000);
            const groundMat = new THREE.MeshBasicMaterial({ color: 0x003366, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = -500;
            scene.add(ground);
            
            // Obstacles
            for (let i = 0; i < 20; i++) {
                const obsGeom = new THREE.BoxGeometry(2, 2, 2);
                const obsMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false });
                const obs = new THREE.Mesh(obsGeom, obsMat);
                obs.position.set((Math.random() - 0.5) * 20, 1, -Math.random() * 500 - 50);
                obstacles.push(obs);
                scene.add(obs);
            }
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function startGameLoop() {
            function animate() {
                requestAnimationFrame(animate);
                
                // Speed control
                if (game.gas && game.speed < game.maxSpeed) {
                    game.speed += game.acceleration;
                }
                if (game.brake && game.speed > 0) {
                    game.speed -= game.braking;
                }
                if (!game.gas && !game.brake && game.speed > 0) {
                    game.speed -= game.friction;
                }
                game.speed = Math.max(0, Math.min(game.maxSpeed, game.speed));
                
                // Steering
                if (game.left) game.steering -= 0.05;
                if (game.right) game.steering += 0.05;
                game.steering = Math.max(-1, Math.min(1, game.steering));
                if (!game.left && !game.right) {
                    game.steering *= 0.9;
                }
                
                game.carX += game.steering * 0.5;
                game.carX = Math.max(-15, Math.min(15, game.carX));
                
                car.position.x = game.carX;
                car.rotation.y = -game.steering * 0.3;
                
                // Move road
                road.forEach(line => {
                    line.position.z += game.speed * 0.1;
                    if (line.position.z > 20) {
                        line.position.z -= 1000;
                    }
                });
                
                // Move obstacles
                obstacles.forEach(obs => {
                    obs.position.z += game.speed * 0.1;
                    if (obs.position.z > 20) {
                        obs.position.z = -Math.random() * 500 - 50;
                        obs.position.x = (Math.random() - 0.5) * 20;
                        game.score++;
                    }
                    
                    // Collision
                    const dist = Math.sqrt(
                        Math.pow(obs.position.x - game.carX, 2) + 
                        Math.pow(obs.position.z, 2)
                    );
                    if (dist < 3) {
                        game.speed *= 0.5;
                    }
                });
                
                document.getElementById('scoreDisplay').textContent = 
                    `SPEED: ${Math.floor(game.speed)} | SCORE: ${game.score}`;
                
                if (connection && connection.open) {
                    connection.send({ speed: game.speed, score: game.score });
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
        }

        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Prevent long press menu on mobile
        document.addEventListener('touchstart', e => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
